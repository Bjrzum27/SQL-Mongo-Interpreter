"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.splitWhereForPushdown=d;const p=require("./build/buildMatch");function d(n){if(!n.where)return{};const t=n.from.alias||n.from.name,e=new Set([t,n.from.name].filter(Boolean)),r=i(n.where),o=[],f=[];for(const c of r)u(c,n,e)?o.push(c):f.push(c);const h=s(o,n),l=s(f,n);return{baseMatch:h,postMatch:l}}function i(n){if(n.type==="BinaryOp"&&n.operator==="AND"){const t=n;return[...i(t.left),...i(t.right)]}return[n]}function s(n,t){if(!n.length)return;const e=n.map(r=>(0,p.buildMatch)(r,t)).filter(r=>r&&Object.keys(r).length);if(e.length)return e.length===1?e[0]:{$and:e}}function u(n,t,e){switch(n.type){case"Literal":return!0;case"ColumnRef":return m(n,e);case"BinaryOp":{const r=n;return u(r.left,t,e)&&u(r.right,t,e)}case"UnaryOp":return u(n.operand,t,e);case"ParenExpression":return u(n.expression,t,e);case"FunctionCall":return n.args.every(r=>u(r,t,e));case"ArithmeticOp":return u(n.left,t,e)&&u(n.right,t,e);case"CaseExpression":{const r=n;return r.branches.every(o=>u(o.when,t,e)&&u(o.then,t,e))&&(!r.else||u(r.else,t,e))}case"InExpression":{const r=n;return r.subquerySql||r.lookupAlias?!1:u(r.left,t,e)&&r.values.every(o=>u(o,t,e))}case"BetweenExpression":{const r=n;return u(r.value,t,e)&&u(r.lower,t,e)&&u(r.upper,t,e)}case"LikeExpression":{const r=n;return u(r.value,t,e)&&u(r.pattern,t,e)}case"ExistsExpression":return!1;default:return!1}}function m(n,t){if(n.paramRef)return!1;const e=n.name.split(".");return e.length===1?!0:t.has(e[0])}
