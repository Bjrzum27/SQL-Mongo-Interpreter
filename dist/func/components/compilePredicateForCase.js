"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.compilePredicateForCase=p;const m=require("../mapColumnToPath"),c=require("../compileValueExpression"),s=require("../normalizeLiteral");function p(u,r){var $,f;switch(u.type){case"BinaryOp":{const e=u;if(["AND","OR"].includes(e.operator)){const o=p(e.left,r),t=p(e.right,r);return e.operator==="AND"?{$and:[o,t]}:{$or:[o,t]}}if(e.left.type==="ColumnRef"&&e.right.type==="Literal"){const o=e.left,t=(0,m.mapColumnToPath)(o,r);if(t&&!(!(($=o.traversal)===null||$===void 0)&&$.length)){const n=(0,s.literalNodeValue)(e.right);switch(e.operator){case"=":return{$eq:["$"+t,n]};case"!=":case"<>":return{$ne:["$"+t,n]};case">":return{$gt:["$"+t,n]};case">=":return{$gte:["$"+t,n]};case"<":return{$lt:["$"+t,n]};case"<=":return{$lte:["$"+t,n]}}}}if(e.left.type==="Literal"&&e.right.type==="ColumnRef"){const o=e.right,t=(0,m.mapColumnToPath)(o,r);if(t&&!(!((f=o.traversal)===null||f===void 0)&&f.length)){const n=(0,s.literalNodeValue)(e.left);switch(e.operator){case"=":return{$eq:[n,"$"+t]};case"!=":case"<>":return{$ne:[n,"$"+t]};case">":return{$lt:["$"+t,n]};case">=":return{$lte:["$"+t,n]};case"<":return{$gt:["$"+t,n]};case"<=":return{$gte:["$"+t,n]}}}}const l=(0,c.compileValueExpression)(e.left,r),a=(0,c.compileValueExpression)(e.right,r),i={"=":"$eq","!=":"$ne","<>":"$ne",">":"$gt",">=":"$gte","<":"$lt","<=":"$lte"};if(i[e.operator]&&l!=null&&a!=null)return{[i[e.operator]]:[l,a]};break}case"BetweenExpression":{const e=u,l=(0,c.compileValueExpression)(e.value,r),a=(0,c.compileValueExpression)(e.lower,r),i=(0,c.compileValueExpression)(e.upper,r);return l==null||a==null||i==null?!0:e.not?{$or:[{$lt:[l,a]},{$gt:[l,i]}]}:{$and:[{$gte:[l,a]},{$lte:[l,i]}]}}case"InExpression":{const e=u,l=(0,c.compileValueExpression)(e.left,r),a=e.values.map(o=>(0,c.compileValueExpression)(o,r)).filter(o=>o!=null);if(l==null||!a.length)return!0;const i={$in:[l,a]};return e.not?{$not:[i]}:i}case"LikeExpression":{const e=u;if(e.pattern.type!=="Literal")return!0;const l=(0,s.literalNodeValue)(e.pattern);if(typeof l!="string")return!0;const i="^"+l.replace(/[.*+?^${}()|[\]\\]/g,n=>"\\"+n).replace(/%/g,".*").replace(/_/g,".")+"$",t={$regexMatch:{input:(0,c.compileValueExpression)(e.value,r),regex:i,options:"i"}};return e.not?{$not:[t]}:t}case"ParenExpression":return p(u.expression,r);case"ColumnRef":{const e=(0,m.mapColumnToPath)(u,r);if(e)return"$"+e;break}case"Literal":return(0,s.literalNodeValue)(u);default:break}const d=(0,c.compileValueExpression)(u,r);return d!=null?d:!0}
