"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildHaving=m;const d=require("./buildMatch"),h=require("../safeFieldAlias"),y=require("../expressionSignature");function m(a,u,o,l,s){const r=new Set;for(const e of Object.keys(o))e.startsWith("_set_")||r.add(e);for(const e of Object.keys(l))r.add(e);for(const e of s.values())r.add(e);const f=new Set((u||[]).map(e=>(0,h.safeFieldAlias)(e)));function t(e){if(e.type==="ColumnRef"){const n=e;if(!n.name.includes(".")){if(r.has(n.name))return n;if(f.has(n.name))return{type:"ColumnRef",name:"_id."+n.name}}return n}if(e.type==="FunctionCall"){const n=e,c=(0,y.expressionSignature)(n),i=s.get(c);return i?{type:"ColumnRef",name:i}:{...n,args:n.args.map(t)}}return e.type==="BinaryOp"?{...e,left:t(e.left),right:t(e.right)}:e.type==="InExpression"?{...e,left:t(e.left),values:e.values.map(t)}:e.type==="BetweenExpression"?{...e,value:t(e.value),lower:t(e.lower),upper:t(e.upper)}:e.type==="LikeExpression"?{...e,value:t(e.value),pattern:t(e.pattern)}:e.type==="ParenExpression"?{...e,expression:t(e.expression)}:e.type==="CaseExpression"?{...e,branches:e.branches.map(n=>({when:t(n.when),then:t(n.then)})),else:e.else?t(e.else):void 0}:e.type==="ArithmeticOp"?{...e,left:t(e.left),right:t(e.right)}:e}const p=t(a);return(0,d.buildMatch)(p)}
