"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SqlExecutor=void 0;const E=require("./parser"),k=require("./compiler"),S=require("./func/compileValueExpression"),q=require("./compileUpdate");class ${constructor(e){this.connection=e,this.correlatedLookupCounter=0,this.correlatedVarCounter=0}async execute(e,n={}){const o=(0,E.parseToAst)(e);if(o.type==="SelectStatement"){const a=o;this.correlatedLookupCounter=0,this.correlatedVarCounter=0,await this.resolveSubqueries(a,a);const s=(0,k.compileToAggregation)(a,n);if(n.debug||process.env.SQL_DEBUG)try{console.log("[sql-interpreter] pipeline:",JSON.stringify(s))}catch{}const i=await this.connection.collection(a.from.name).aggregate(s).toArray();return{ast:a,pipeline:s,data:i}}return this.executeUpdate(o,n)}async executeUpdate(e,n){var o;const a=await this.resolveScalarSubqueriesInUpdate(e),{filter:s,updatePipeline:t,limitOne:i,setStage:l,unsetFields:h}=(0,q.compileUpdate)(e,{scalarLookups:a}),u=this.buildReturningInfo(e);if(n.debug||process.env.SQL_DEBUG)try{console.log("[sql-interpreter] update filter:",JSON.stringify(s)),console.log("[sql-interpreter] update pipeline:",JSON.stringify(t))}catch{}const d=this.connection.collection(e.target.name),r=i&&typeof d.updateOne=="function"&&a.length===0,c=e.returning?!0:(o=n.returnUpdatedDocs)!==null&&o!==void 0?o:!0,g=s&&typeof s=="object"&&Object.keys(s).length>0;let p=[];if(c&&(g||i)){const f=[];g&&f.push({$match:s}),i&&f.push({$limit:1});try{p=await d.aggregate(f).toArray()}catch{p=[]}}const w=a.length?await this.executeCorrelatedUpdate(d,{filter:s,updatePipeline:t,setStage:l,unsetFields:h,limitOne:i}):r?await d.updateOne.call(d,s,t):await d.updateMany(s,t);let y;if(c){const f=Array.isArray(p)?p.map(m=>m&&typeof m=="object"?m._id:void 0).filter(m=>m!=null):[];let b;f.length===1?b={_id:f[0]}:f.length>1?b={_id:{$in:f}}:g?b=s:e.returning&&(b=s&&typeof s=="object"?s:{});let v=!1;if(b){const m=[];b&&typeof b=="object"&&Object.keys(b).length>0&&m.push({$match:b}),i&&m.push({$limit:1}),u.pipeline.length&&m.push(...u.pipeline);try{y=await d.aggregate(m).toArray(),v=u.pipeline.length>0}catch{y=p,v=!1}}else p.length&&i?(y=p.map(m=>Object.assign({},m)),v=!1):(y=[],v=!1);y&&u.projectSpec&&!u.useFullDocument&&!v&&(y=y.map(m=>u.applyProjectionFallback(m)))}return{ast:e,filter:s,update:t,result:w,data:y}}async resolveScalarSubqueriesInUpdate(e){const n=[],o=(0,q.createUpdateContext)(e),a=async t=>{if(t.processed||(t.processed=!0,!t.subquerySql))return;const i=(0,E.parseToAst)(t.subquerySql);if(i.type!=="SelectStatement")throw new Error("Las subconsultas escalares deben ser SELECT");const l=i;await this.resolveSubqueries(l,l);const h=this.markCorrelatedReferences(l,o,o);if(h){const u=`__upd_subq_${this.correlatedLookupCounter++}`,d=this.determineSubqueryOutputField(l,[]);t.lookupAlias=u,t.valueField=d,t.variables=h.variables,t.subqueryAst=h.subquery,t.resolved=!1,t.subquerySql=void 0,n.push({alias:u,variables:h.variables,subquery:h.subquery})}else{const u=(0,k.compileToAggregation)(l,{limit:1}),d=this.connection.collection(l.from.name);let r=[];try{r=await d.aggregate(u).toArray()}catch{r=[]}const c=this.determineSubqueryOutputField(l,r),g=r.length?r[0]:void 0;let p=null;g&&typeof g=="object"&&g!==null&&(p=Object.prototype.hasOwnProperty.call(g,c)?g[c]:null),t.resolved=!0,t.resolvedValue=p!=null?p:null,t.subquerySql=void 0,t.lookupAlias=void 0,t.valueField=void 0,t.variables=void 0,t.subqueryAst=void 0}},s=async t=>{if(t)switch(t.type){case"BinaryOp":await s(t.left),await s(t.right);break;case"ArithmeticOp":await s(t.left),await s(t.right);break;case"FunctionCall":for(const i of t.args)await s(i);break;case"CaseExpression":for(const i of t.branches)await s(i.when),await s(i.then);t.else&&await s(t.else);break;case"InExpression":{const i=t;await s(i.left);for(const l of i.values)await s(l);break}case"BetweenExpression":{const i=t;await s(i.value),await s(i.lower),await s(i.upper);break}case"LikeExpression":await s(t.value),await s(t.pattern);break;case"ParenExpression":await s(t.expression);break;case"ExistsExpression":break;case"ArrayExpression":for(const i of t.elements)await s(i);break;case"ScalarSubquery":await a(t);break;default:break}};for(const t of e.assignments)if(t.value&&await s(t.value),t.values)for(const i of t.values)await s(i);return e.where&&await s(e.where),n}async executeCorrelatedUpdate(e,n){const{filter:o,updatePipeline:a,setStage:s,unsetFields:t,limitOne:i}=n,l=[];o&&typeof o=="object"&&Object.keys(o).length>0&&l.push({$match:o}),i&&l.push({$limit:1});for(const w of a)l.push(w);let u=[];try{u=await e.aggregate(l).toArray()}catch{u=[]}const d=Object.keys(s||{}),r=d.length>0,c=Array.isArray(t)&&t.length>0;let g=0,p=0;for(const w of u){if(!w||w._id==null)continue;const y={};if(r){const b={};for(const v of d){const m=this.getValueAtPath(w,v);b[v]=m===void 0?null:m}Object.keys(b).length&&(y.$set=b)}if(c){const b={};for(const v of t)b[v]="";Object.keys(b).length&&(y.$unset=b)}if(!Object.keys(y).length)continue;let f;typeof e.updateOne=="function"?f=await e.updateOne.call(e,{_id:w._id},y):f=await e.updateMany({_id:w._id},y),g+=typeof(f==null?void 0:f.matchedCount)=="number"?f.matchedCount:1,p+=typeof(f==null?void 0:f.modifiedCount)=="number"?f.modifiedCount:typeof(f==null?void 0:f.matchedCount)=="number"?f.matchedCount:1}return{matchedCount:g,modifiedCount:p}}getValueAtPath(e,n){if(!e||!n)return;const o=n.split(".");let a=e;for(const s of o){if(a==null||typeof a!="object")return;a=a[s]}return a}async resolveSubqueries(e,n,o){const a=async s=>{if(s)switch(s.type){case"BinaryOp":await a(s.left),await a(s.right);break;case"InExpression":await this.processInExpression(s,a,n,e);break;case"ExistsExpression":await this.processExistsExpression(s,n,e);break;case"BetweenExpression":await a(s.value),await a(s.lower),await a(s.upper);break;case"LikeExpression":await a(s.value),await a(s.pattern);break;case"ParenExpression":await a(s.expression);break;case"FunctionCall":for(const t of s.args)await a(t);break;case"ArithmeticOp":await a(s.left),await a(s.right);break;case"CaseExpression":for(const t of s.branches)await a(t.when),await a(t.then);s.else&&await a(s.else);break;case"ArrayExpression":for(const t of s.elements||[])await a(t);break;default:break}};await a(e.where);for(const s of e.joins)await a(s.on);e.having&&await a(e.having)}async processInExpression(e,n,o,a){await n(e.left);for(const c of e.values)await n(c);if(!e.subquerySql)return;const s=(0,E.parseToAst)(e.subquerySql);if(s.type!=="SelectStatement")throw new Error("Las subconsultas IN deben ser SELECT");const t=s;await this.resolveSubqueries(t,o,a);const i=this.markCorrelatedReferences(t,a,o);if(i){const c=this.determineSubqueryOutputField(t,[]),g=`__in_lookup_${this.correlatedLookupCounter++}`;e.lookupAlias=g,e.lookupValueField=c,e.values=[],a.correlatedLookups||(a.correlatedLookups=[]),a.correlatedLookups.push({kind:"in",lookupAlias:g,lookupValueField:c,variables:i.variables,subquery:i.subquery,node:e}),delete e.subquerySql;return}const l=(0,k.compileToAggregation)(t),u=await this.connection.collection(t.from.name).aggregate(l).toArray(),d=this.determineSubqueryOutputField(t,u),r=[];if(d)for(const c of u)c&&Object.prototype.hasOwnProperty.call(c,d)&&r.push(c[d]);e.values=r.map(c=>({type:"Literal",value:c})),e.resolvedFromSubquery=!0,e.subqueryEmpty=r.length===0,delete e.subquerySql}async processExistsExpression(e,n,o){if(!e.subquerySql)return;const a=(0,E.parseToAst)(e.subquerySql);if(a.type!=="SelectStatement")throw new Error("Las subconsultas EXISTS deben ser SELECT");const s=a;await this.resolveSubqueries(s,n,o);const t=this.markCorrelatedReferences(s,o,n);if(t){const d=`__exists_lookup_${this.correlatedLookupCounter++}`;e.lookupAlias=d,o.correlatedLookups||(o.correlatedLookups=[]),o.correlatedLookups.push({kind:"exists",lookupAlias:d,variables:t.variables,subquery:t.subquery,node:e}),delete e.subquerySql;return}const i=(0,k.compileToAggregation)(s),u=(await this.connection.collection(s.from.name).aggregate(i).toArray()).length>0;e.value=e.not?!u:u,e.resolved=!0,delete e.subquerySql}markCorrelatedReferences(e,n,o){const a=this.collectAliases(e),s=new Set;for(const r of this.collectAliases(n))s.add(r);if(o!==n)for(const r of this.collectAliases(o))s.add(r);const t=new Map,i=new Map;let l=!1;const h=r=>{var c;if(!r.name.includes("."))return;const p=r.name.split(".")[0];if(a.has(p))return;if(!s.has(p))throw new Error(`Alias correlacionado no reconocido: ${p}`);const w=((c=r.traversal)===null||c===void 0?void 0:c.join("."))||"",y=`${r.name}|${w}`;let f=i.get(y);if(!f){const b={type:"ColumnRef",name:r.name,traversal:r.traversal?[...r.traversal]:void 0},v=(0,S.compileValueExpression)(b,n);if(v==null)throw new Error(`No se pudo resolver la referencia correlacionada ${r.name}`);f=`corr${this.correlatedVarCounter++}`,i.set(y,f),t.set(f,v)}r.paramRef=f,l=!0},u=r=>{if(r)switch(r.type){case"ColumnRef":h(r);break;case"BinaryOp":u(r.left),u(r.right);break;case"InExpression":{const c=r;u(c.left);for(const g of c.values)u(g);break}case"BetweenExpression":{const c=r;u(c.value),u(c.lower),u(c.upper);break}case"LikeExpression":u(r.value),u(r.pattern);break;case"ParenExpression":u(r.expression);break;case"FunctionCall":for(const c of r.args)u(c);break;case"ArithmeticOp":u(r.left),u(r.right);break;case"CaseExpression":for(const c of r.branches)u(c.when),u(c.then);r.else&&u(r.else);break;case"ArrayExpression":for(const c of r.elements)u(c);break;default:break}};for(const r of e.columns)r.type==="ColumnRef"?u(r):r.type==="AliasedExpression"&&u(r.expression);u(e.where);for(const r of e.joins)u(r.on);if(e.groupBy)for(const r of e.groupBy)u(r);if(e.orderBy)for(const r of e.orderBy)u(r.expression);if(e.having&&u(e.having),!l)return null;const d={};for(const[r,c]of t.entries())d[r]=c;return{variables:d,subquery:e}}collectAliases(e){const n=new Set;n.add(e.from.alias||e.from.name);for(const o of e.joins)n.add(o.source.alias||o.source.name);return n}determineSubqueryOutputField(e,n){if(!e.columns.length)throw new Error("La subconsulta IN debe seleccionar al menos una columna");if(e.columns.length>1)throw new Error("La subconsulta IN solo soporta una columna");const o=e.columns[0];if(o.type==="Wildcard")throw new Error("La subconsulta IN no soporta SELECT *");let a;if(o.type==="ColumnRef"){const l=o;a=l.alias||l.name.split(".").slice(-1)[0]}else a=o.alias;if(!n.length||n.some(l=>l&&Object.prototype.hasOwnProperty.call(l,a)))return a;const t=n.find(l=>l&&Object.keys(l).length);if(!t)return a;const i=Object.keys(t).find(l=>l!=="_id");return i||(Object.prototype.hasOwnProperty.call(t,"_id")?"_id":a)}buildReturningInfo(e){const n=e.returning;if(!n||!n.items.length)return{useFullDocument:!0,pipeline:[],projectSpec:void 0,applyProjectionFallback:t=>t};if(n.items.length===1&&n.items[0].type==="Wildcard"&&!n.items[0].source)return{useFullDocument:!0,pipeline:[],projectSpec:void 0,applyProjectionFallback:t=>t};for(const t of n.items)if(t.type==="Wildcard")throw new Error("RETURNING con alias.* no est\xE1 soportado en UPDATE");const o=(0,q.createUpdateContext)(e),a={},s=new Set;for(const t of n.items){let i,l;if(t.type==="ColumnRef"){const h=t;i=h.alias||h.name.split(".").slice(-1)[0],l=(0,S.compileValueExpression)(h,o)}else{const h=t;i=h.alias,l=(0,S.compileValueExpression)(h.expression,o)}if(l==null)throw new Error(`No se pudo compilar la expresi\xF3n RETURNING para ${i}`);if(s.has(i))throw new Error("Alias duplicado en RETURNING: "+i);s.add(i),a[i]=l}return s.has("_id")||(a._id=0),{useFullDocument:!1,pipeline:[{$project:a}],projectSpec:a,applyProjectionFallback:t=>this.evaluateProjectSpec(t,a)}}evaluateProjectSpec(e,n){if(!e||typeof e!="object")return e;const o={};for(const[a,s]of Object.entries(n))if(s!==0){if(s===1){o[a]=this.getValueFromDoc(e,a);continue}o[a]=this.evaluateMongoExpression(s,e)}return o}getValueFromDoc(e,n){if(!n)return;const o=n.split(".");let a=e;for(const s of o){if(a==null)return;a=a[s]}return a}evaluateMongoExpression(e,n){var o;if(Array.isArray(e))return e.map(a=>this.evaluateMongoExpression(a,n));if(e&&typeof e=="object"){if(e.$add){const[s,t]=e.$add.map(i=>this.evaluateMongoExpression(i,n));return s+t}if(e.$subtract){const[s,t]=e.$subtract.map(i=>this.evaluateMongoExpression(i,n));return s-t}if(e.$multiply){const[s,t]=e.$multiply.map(i=>this.evaluateMongoExpression(i,n));return s*t}if(e.$divide){const[s,t]=e.$divide.map(i=>this.evaluateMongoExpression(i,n));return t===0?null:s/t}if(e.$ifNull){const[s,t]=e.$ifNull.map(i=>this.evaluateMongoExpression(i,n));return s==null?t:s}if(e.$cond){const[s,t,i]=e.$cond;return this.evaluateMongoExpression(s,n)?this.evaluateMongoExpression(t,n):this.evaluateMongoExpression(i,n)}if(e.$let){const s=e.$let.vars||{},t={};for(const[i,l]of Object.entries(s))t[i]=this.evaluateMongoExpression(l,n);return this.evaluateMongoExpressionWithVars(e.$let.in,n,t)}if(e.$dateAdd){const s=this.evaluateMongoExpression(e.$dateAdd.startDate,n),t=(o=this.evaluateMongoExpression(e.$dateAdd.amount,n))!==null&&o!==void 0?o:0,i=e.$dateAdd.unit;if(!s)return null;const l=new Date(s);if(Number.isNaN(l.getTime()))return null;const h=this.addUnitToDate(i,t);return new Date(l.getTime()+h).toISOString()}if(e.$dateTrunc){const s=this.evaluateMongoExpression(e.$dateTrunc.date,n);if(!s)return null;const t=new Date(s);return Number.isNaN(t.getTime())?null:(e.$dateTrunc.unit==="day"&&t.setUTCHours(0,0,0,0),t.toISOString())}if(e.$dateToString){const s=this.evaluateMongoExpression(e.$dateToString.date,n);if(!s)return null;const t=new Date(s);return Number.isNaN(t.getTime())?null:e.$dateToString.format==="%H:%M:%S"?t.toISOString().substring(11,19):e.$dateToString.format==="%Y-%m-%d"?t.toISOString().substring(0,10):t.toISOString()}return e.$concatArrays?e.$concatArrays.map(t=>{const i=this.evaluateMongoExpression(t,n);return Array.isArray(i)?i:i==null?[]:[i]}).reduce((t,i)=>t.concat(i),[]):Object.fromEntries(Object.entries(e).map(([s,t])=>[s,this.evaluateMongoExpression(t,n)]))}return typeof e=="string"?e.startsWith("$$")?void 0:e.startsWith("$")?this.getValueFromDoc(n,e.substring(1)):e:e}evaluateMongoExpressionWithVars(e,n,o){if(Array.isArray(e))return e.map(a=>this.evaluateMongoExpressionWithVars(a,n,o));if(e&&typeof e=="object"){if(e.$let){const s={...o};for(const[t,i]of Object.entries(e.$let.vars||{}))s[t]=this.evaluateMongoExpressionWithVars(i,n,o);return this.evaluateMongoExpressionWithVars(e.$let.in,n,s)}if(e.$cond){const[s,t,i]=e.$cond;return this.evaluateMongoExpressionWithVars(s,n,o)?this.evaluateMongoExpressionWithVars(t,n,o):this.evaluateMongoExpressionWithVars(i,n,o)}if(e.$ifNull){const[s,t]=e.$ifNull,i=this.evaluateMongoExpressionWithVars(s,n,o);return i==null?this.evaluateMongoExpressionWithVars(t,n,o):i}const a={};for(const[s,t]of Object.entries(e))a[s]=this.evaluateMongoExpressionWithVars(t,n,o);return a}if(typeof e=="string"){if(e.startsWith("$$")){const a=e.substring(2);return o[a]}return e.startsWith("$")?this.getValueFromDoc(n,e.substring(1)):e}return e}addUnitToDate(e,n){const o={millisecond:n/36e5,second:n/3600,minute:n/60,hour:n,day:n*24};return e==="millisecond"?n:e==="second"?n*1e3:e==="minute"?n*6e4:e==="hour"?n*36e5:e==="day"?n*864e5:e==="week"?n*7*864e5:e==="month"?n*30*864e5:e==="year"?n*365*864e5:e in o?o[e]*36e5:n}}exports.SqlExecutor=$;
