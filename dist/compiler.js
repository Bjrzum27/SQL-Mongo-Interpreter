"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.compileToAggregation=T;const G=require("./func/registerAggregateFunction"),M=require("./func/mapColumnToPath"),O=require("./func/compileValueExpression"),H=require("./func/expressionSignature"),L=require("./func/collectAggregateFunctions"),W=require("./func/finalProjectionFields"),N=require("./func/applyOrderBy"),B=require("./func/safeFieldAlias"),z=require("./func/build/buildProjection"),J=require("./func/build/buildJoinLookup"),X=require("./func/build/buildHaving"),Z=require("./func/splitHavingPushdown"),D=require("./func/splitWherePushdown"),P=new Set(["COUNT","SUM","AVG","MIN","MAX","COUNT_IF"]);function T(o,I={}){var _,j,$,x,v,C,F;const s=[];let y;const q=o.correlatedLookups||[],U=q.map(e=>e.lookupAlias),{baseMatch:b,postMatch:R}=(0,D.splitWhereForPushdown)(o);b&&Object.keys(b).length&&s.push({$match:b});const k=R;for(const e of o.joins){const l=(0,J.buildJoinLookup)(e,o.from.alias||o.from.name);s.push(...l)}for(const e of q){const l={};for(const[t,u]of Object.entries(e.variables))l[t]=u;const a=T(e.subquery,e.kind==="exists"?{limit:(_=e.limit)!==null&&_!==void 0?_:1}:{});s.push({$lookup:{from:e.subquery.from.name,let:l,pipeline:a,as:e.lookupAlias}})}k&&Object.keys(k).length&&s.push({$match:k});const S=o.columns.some(e=>e.type==="AliasedExpression"&&e.expression.type==="FunctionCall"&&P.has(e.expression.name.toUpperCase())),g=o.groupBy||(o.distinct?o.columns.filter(e=>e.type==="ColumnRef"):void 0);if(S||g){const e=i=>i.replace(/[^A-Za-z0-9_]/g,"_"),l=new Map;for(const i of o.columns)if(i.type==="AliasedExpression"){const n=i,r=n.expression.type==="FunctionCall"?(n.expression.name||"").toUpperCase():"";if(r&&P.has(r))continue;l.set(e(n.alias).toUpperCase(),{expression:n.expression,field:e(n.alias)})}else if(i.type==="ColumnRef"&&i.alias){const n=i;l.set(e(n.alias).toUpperCase(),{expression:n,field:e(n.alias)})}const a={},t={};if(g&&g.length)for(const i of g){const n=(0,B.safeFieldAlias)(i),r=l.get(e(i.name).toUpperCase());if(r)r.field in a||(a[r.field]=(0,O.compileValueExpression)(r.expression,o)),t[n]="$"+r.field;else{const c=(0,M.mapColumnToPath)(i,o);c&&(t[n]="$"+c)}}else t._all=null;const u={},f={},d=new Set,p=new Map,h=new Map;let V=0;for(const i of o.columns){if(i.type!=="AliasedExpression")continue;const n=i;if(n.expression.type!=="FunctionCall")continue;const r=n.expression,c=r.name.toUpperCase();if(!P.has(c))continue;const m=n.alias,E=(0,H.expressionSignature)(r);p.has(E)||p.set(E,m),h.has(m)||h.set(m,r),d.add(m)}if(o.having){const i=new Map;(0,L.collectAggregateFunctions)(o.having,i);for(const[n,r]of i){let c=p.get(n);c||(c=`__having_${V++}`,p.set(n,c)),h.has(c)||h.set(c,r)}}for(const[i,n]of h.entries())(0,G.registerAggregateFunction)(n,i,u,f,o);if(Object.keys(a).length&&s.push({$addFields:a}),s.push({$group:{_id:t,...u}}),Object.keys(f).length&&s.push({$addFields:f}),o.having){const i=(0,X.buildHaving)(o.having,g,u,f,p);if(Object.keys(i).length){const{pushable:n,remaining:r}=(0,Z.splitHavingPushdown)(i);if(n){const c=s.findIndex(m=>m.$group);c>-1&&(c===0||!s[c-1].$match?s.splice(c,0,{$match:n}):s[c-1]={$match:{$and:[s[c-1].$match,n]}})}r&&s.push({$match:r})}}const A={};if(g&&g.length)for(const i of g){const n=(0,B.safeFieldAlias)(i);A[n]="$_id."+n}for(const i of d)A[i]="$"+i;if(!g&&!S&&o.distinct){for(const i of o.columns)if(i.type==="ColumnRef"){const n=i.alias||i.name.split(".").slice(-1)[0];A[n]="$_id."+(0,B.safeFieldAlias)(i)}}Object.keys(A).length&&s.push({$project:A})}else{const e=(0,z.buildProjection)(o);y=e.pathToAlias;const l=new Set;for(const t of o.columns)(t.type==="AliasedExpression"||t.type==="ColumnRef"&&t.alias)&&l.add(t.alias.toUpperCase());const a=!!(!((j=o.orderBy)===null||j===void 0)&&j.some(t=>t.expression.type==="ColumnRef"&&l.has(t.expression.name.toUpperCase())));!(($=o.orderBy)===null||$===void 0)&&$.length&&!a?((0,N.applyOrderBy)(o,s,void 0),e.includeAllBase?e.project&&s.push({$addFields:e.project}):e.project&&s.push({$project:e.project})):(e.includeAllBase?e.project&&s.push({$addFields:e.project}):e.project&&s.push({$project:e.project}),!((x=o.orderBy)===null||x===void 0)&&x.length&&(0,N.applyOrderBy)(o,s,y))}if(!((v=o.orderBy)===null||v===void 0)&&v.length&&s.findIndex(e=>e.$sort)===-1){const e={},l={},a=[];let t=0;for(const u of o.orderBy){const f=u.expression;let d;if(f.type==="ColumnRef"){const p=f.name,h=(0,M.mapColumnToPath)(f,o);h?y&&y[h]?d=y[h]:d=h:p.includes(".")||(d=p)}else if(f.type==="FunctionCall"||f.type==="ArithmeticOp"||f.type==="CaseExpression"){const p="__ord"+t++;l[p]=(0,O.compileValueExpression)(f,o),d=p,a.push(p)}else{const p="__ord"+t++;l[p]=(0,O.compileValueExpression)(f,o),d=p,a.push(p)}d&&(e[d]=u.direction==="ASC"?1:-1)}if(Object.keys(l).length&&s.push({$addFields:l}),Object.keys(e).length&&s.push({$sort:e}),a.length){const u=(0,W.finalProjectionFields)(s);Object.keys(u).length?s.push({$project:{...u}}):s.push({$unset:a})}}o.offset&&s.push({$skip:o.offset});const w=(C=I.limit)!==null&&C!==void 0?C:o.limit;if(w&&s.push({$limit:w}),U.length&&s.push({$unset:U}),o.reorderFinal&&(!((F=o.orderBy)===null||F===void 0)&&F.length)){const e=o.orderBy[0];let l;const a=s.find(t=>t.$sort);if(a){const t=Object.keys(a.$sort);t.length&&(l=t[0])}l&&s.push({$sort:{[l]:o.reorderFinal.direction==="ASC"?1:-1}})}return s}
